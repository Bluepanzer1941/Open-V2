// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define ARRAY_BACKING(container_name) template<typename obj_type> RELEASE_INLINE auto array_backing() noexcept -> std::enable_if_t<std::is_same_v<typename decltype(container_name.array_backing<obj_type>())::contents_type, obj_type>, decltype(container_name.array_backing<obj_type>())> { return container_name.array_backing<obj_type>(); } template<typename obj_type> RELEASE_INLINE auto array_backing() const noexcept -> std::enable_if_t<std::is_same_v<typename decltype(container_name.array_backing<obj_type>())::contents_type, obj_type>, decltype(container_name.array_backing<obj_type>())> { return container_name.array_backing<obj_type>(); }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define GET_SET(container_name) template<typename INDEX, typename tag_type> RELEASE_INLINE auto get(tag_type t) noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get<INDEX>(t)), void>, decltype(container_name.get<INDEX>(t))> { return container_name.get<INDEX>(t); } template<typename INDEX, typename tag_type> RELEASE_INLINE auto get(tag_type t) const noexcept-> std::enable_if_t<!std::is_same_v<decltype(container_name.get<INDEX>(t)), void>, decltype(container_name.get<INDEX>(t))> { return container_name.get<INDEX>(t); } template<typename INDEX, typename tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, value_type v) noexcept -> std::enable_if_t<std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get<INDEX>(t)), void>, void> { return container_name.set<INDEX>(t, v); } template<typename INDEX, typename tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, value_type const& v) noexcept -> std::enable_if_t<!std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get<INDEX>(t)), void>, void> { return container_name.set<INDEX>(t, v); } template<typename INDEX> RELEASE_INLINE auto get_row() noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get_row<INDEX>()), void>, decltype(container_name.get_row<INDEX>())> { return container_name.get_row<INDEX>(); } template<typename INDEX> RELEASE_INLINE auto get_row() const noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get_row<INDEX>()), void>, decltype(container_name.get_row<INDEX>())> { return container_name.get_row<INDEX>(); } template<typename INDEX, typename tag_type, typename inner_tag_type> RELEASE_INLINE auto get(tag_type t, inner_tag_type u) noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get<INDEX>(t,u)), void>, decltype(container_name.get<INDEX>(t,u))> { return container_name.get<INDEX>(t,u); } template<typename INDEX, typename tag_type, typename inner_tag_type> RELEASE_INLINE auto get(tag_type t, inner_tag_type u) const noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get<INDEX>(t,u)), void>, decltype(container_name.get<INDEX>(t,u))> { return container_name.get<INDEX>(t,u); } template<typename INDEX, typename tag_type, typename inner_tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, inner_tag_type u, value_type v) noexcept -> std::enable_if_t<std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get<INDEX>(t,u)), void>, void> { return container_name.set<INDEX>(t, u, v); } template<typename INDEX, typename tag_type, typename inner_tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, inner_tag_type u, value_type const& v) noexcept -> std::enable_if_t<!std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get<INDEX>(t,u)), void>, void> { return container_name.set<INDEX>(t, u, v); } template<typename INDEX, typename tag_type> RELEASE_INLINE auto get_row(tag_type t) noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get_row<INDEX>(t)), void>, decltype(container_name.get_row<INDEX>(t))> { return container_name.get_row<INDEX>(t); } template<typename INDEX, typename tag_type> RELEASE_INLINE auto get_row(tag_type t) const noexcept -> std::enable_if_t<!std::is_same_v<decltype(container_name.get_row<INDEX>(t)), void>, decltype(container_name.get_row<INDEX>(t))> { return container_name.get_row<INDEX>(t); }