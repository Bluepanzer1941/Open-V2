// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define ARRAY_BACKING_BASE(container_name) template<typename obj_type> RELEASE_INLINE auto array_backing() noexcept -> std::enable_if_t<std::is_same_v<container_name::contents_type, obj_type>, std::add_lvalue_reference_t<decltype(container_name)>> { return container_name; } template<typename obj_type> RELEASE_INLINE auto array_backing() const noexcept -> std::enable_if_t<std::is_same_v<container_name::contents_type, obj_type>, std::add_lvalue_reference_t<std::add_const_t<decltype(container_name)>>> { return container_name; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define GET_SET_TFV(index_name, container_name) template<typename INDEX, typename tag_type, typename inner_tag_type> RELEASE_INLINE auto get(tag_type t, inner_tag_type u) noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && !std::is_same_v<decltype(container_name.get(t,u)), void>, decltype(container_name.get(t,u))> { return container_name.get(t,u); } template<typename INDEX, typename tag_type, typename inner_tag_type> RELEASE_INLINE auto get(tag_type t, inner_tag_type u) const noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && !std::is_same_v<decltype(container_name.get(t,u)), void>, decltype(container_name.get(t,u))> { return container_name.get(t,u); } template<typename INDEX, typename tag_type, typename inner_tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, inner_tag_type u, value_type v) noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get(t,u)), void>, void> { return container_name.set(t, u, v); } template<typename INDEX, typename tag_type, typename inner_tag_type, typename value_type> RELEASE_INLINE auto set(tag_type t, inner_tag_type u, value_type const& v) noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && !std::is_trivially_copyable_v<value_type> && !std::is_same_v<decltype(container_name.get(t,u)), void>, void> { return container_name.set(t, u, v); } template<typename INDEX, typename tag_type> RELEASE_INLINE auto get_row(tag_type t) noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && !std::is_same_v<decltype(container_name.get_row(t)), void>, decltype(container_name.get_row(t))> { return container_name.get_row(t); } template<typename INDEX, typename tag_type> RELEASE_INLINE auto get_row(tag_type t) const noexcept -> std::enable_if_t<std::is_same_v<INDEX, index_name> && !std::is_same_v<decltype(container_name.get_row(t)), void>, decltype(container_name.get_row(t))> { return container_name.get_row(t); }
